/*
    w3l: a PvPGN loader for Warcraft 3 1.22+
    Copyright (C) 2008 Rupan, Keres, Phatdeeva

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "w3lh.h"
//#define DO_HASH_OFFSET 0x85B74C
//#define DO_HASH_OFFSET 0x85BE1E

typedef struct _sig {
	int length;	/* length of signature data */
	/* signature data. This is an array of size 'length' * 2
	   with each entry if the format of mask,val where mask
	   is logical anded with the current byte being searched and
	   then compared with val. This way you can ignore certain bytes
	   in a signature */
	char *data;
	/* delta is added to the offset of where the signature was found */
	int delta;
	char *name; /* identifier (optional) */
} t_sig;

typedef struct _patch {
	int length; /* length of patch */
	char *data; /* patch data, an array of bytes of size 'length' */
	char *name; /* identifier (optional) */
} t_patch;

#if ! defined USE_SRP3
/* Used to find the code for hash_init */
char hash_init_sig_data[] = {
	0xff,0xCC, 0xff,0xCC, 0xff,0x33, 0xff,0xC0, 0xff,0xC7, 0xff,0x01, 
	0xff,0x01, 0xff,0x23, 0xff,0x45, 0xff,0x67, 0xff,0xC7, 0xff,0x41, 
	0xff,0x04, 0xff,0x89, 0xff,0xAB, 0xff,0xCD, 0xff,0xEF, 0xff,0xC7, 
	0xff,0x41, 0xff,0x08, 0xff,0xFE, 0xff,0xDC, 0xff,0xBA, 0xff,0x98, 
	0xff,0xC7, 0xff,0x41, 0xff,0x0C, 0xff,0x76, 0xff,0x54, 0xff,0x32, 
	0xff,0x10, 0xff,0xC7, 0xff,0x41, 0xff,0x10, 0xff,0xF0, 0xff,0xE1, 
	0xff,0xD2, 0xff,0xC3, 0xff,0x89, 0xff,0x41, 0xff,0x18, 0xff,0x89, 
	0xff,0x41, 0xff,0x14, 0xff,0xC3, 0xff,0xCC
};

t_sig hash_init_sig = {
	46,
	hash_init_sig_data,
	2,
	"hash_init"
};

/* Used to find the code for hash routine */
char do_hash_sig_data[] = {
	0xff,0x81, 0xff,0xEC, 0xff,0x48, 0xff,0x01, 0xff,0x00, 0xff,0x00, 
	0xff,0x53, 0xff,0x55, 0xff,0x8B, 0xff,0xAC, 0xff,0x24, 0xff,0x54, 
	0xff,0x01, 0xff,0x00, 0xff,0x00, 0xff,0x8B, 0xff,0x45, 0xff,0x14, 
	0xff,0x8B, 0xff,0x55, 0xff,0x1C, 0xff,0x8B, 0xff,0x4D, 0xff,0x18, 
	0xff,0x89, 0xff,0x44, 0xff,0x24, 0xff,0x10, 0xff,0x8B, 0xff,0x45, 
	0xff,0x20, 0xff,0x89, 0xff,0x54, 0xff,0x24, 0xff,0x18, 0xff,0x8B, 
	0xff,0x55, 0xff,0x28, 0xff,0x89, 0xff,0x4C, 0xff,0x24, 0xff,0x14, 
	0xff,0x8B, 0xff,0x4D, 0xff,0x24, 0xff,0x89, 0xff,0x44, 0xff,0x24, 
	0xff,0x1C, 0xff,0x8B, 0xff,0x45, 0xff,0x2C, 0xff,0x89, 0xff,0x54, 
	0xff,0x24, 0xff,0x24, 0xff,0x8B, 0xff,0x55, 0xff,0x34, 0xff,0x89, 
	0xff,0x4C, 0xff,0x24, 0xff,0x20, 0xff,0x8B, 0xff,0x4D, 0xff,0x30, 
	0xff,0x89, 0xff,0x44, 0xff,0x24, 0xff,0x28, 0xff,0x8B, 0xff,0x45, 
	0xff,0x38, 0xff,0x89, 0xff,0x54, 0xff,0x24, 0xff,0x30, 0xff,0x8B, 
	0xff,0x55, 0xff,0x40, 0xff,0x89, 0xff,0x4C, 0xff,0x24, 0xff,0x2C, 
	0xff,0x8B, 0xff,0x4D, 0xff,0x3C, 0xff,0x89, 0xff,0x44, 0xff,0x24, 
	0xff,0x34, 0xff,0x8B, 0xff,0x45, 0xff,0x44, 0xff,0x89, 0xff,0x54, 
	0xff,0x24, 0xff,0x3C, 0xff,0x8B, 0xff,0x55, 0xff,0x4C
};

t_sig do_hash_sig = {
	101,
	do_hash_sig_data,
	0,
	"do_hash"
};


/* Used to find the location of the function that hashes the password for
   the CLIENT_LOGONPROOFREQ packet */
char logon_proof_hash_sig_data[] = {
	0xff,0x83, 0xff,0xEC, 0xff,0x3C, 0xff,0xA1, 0x00,0x00, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0xff,0x33, 0xff,0xC4, 0xff,0x89, 0xff,0x44, 
	0xff,0x24, 0xff,0x38, 0xff,0x53, 0xff,0x55, 0xff,0x8B, 0xff,0x6C, 
	0xff,0x24, 0xff,0x4C, 0xff,0x56, 0xff,0x8B, 0xff,0x74, 0xff,0x24, 
	0xff,0x4C, 0xff,0x57, 0xff,0x8B, 0xff,0xF9, 0xff,0x8B, 0xff,0x4C, 
	0xff,0x24, 0xff,0x58, 0xff,0xBA, 0xff,0x20, 0xff,0x00, 0xff,0x00, 
	0xff,0x00, 0xff,0x89, 0xff,0x6C, 0xff,0x24, 0xff,0x20, 0xff,0x89, 
	0xff,0x4C, 0xff,0x24, 0xff,0x1C, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0xff,0x8B, 0xff,0xD8, 0xff,0x33, 0xff,0xD2, 
	0xff,0x8B, 0xff,0xCB, 0xff,0x89, 0xff,0x5C, 0xff,0x24, 0xff,0x14, 
	0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xff,0x83, 
	0xff,0xF8, 0xff,0x01, 0xff,0x74, 0xff,0x1E, 0xff,0x8B, 0xff,0xCB, 
	0xff,0xE8, 0xff,0x03, 0xff,0x20, 0xff,0x00, 0xff,0x00
};

t_sig logon_proof_hash_sig = {
	77,
	logon_proof_hash_sig_data,
	0,
	"logon_proof_hash"
};

/* Patches aforementioned function to generate a PvPGN friendly 
   password hash for CLIENT_LOGONPROOFREQ packet */
char logon_proof_hash_patch_data[] = {
	0x55, 0x8B, 0xEC, 0x60, 0x83, 0xEC, 0x54, 0x89, 0xE1, 0xE8, 
	0x00, 0x00, 0x00, 0x00, 0x6A, 0x40, 0x59, 0x8D, 0x7C, 0x24, 
	0x14, 0x89, 0xFA, 0x29, 0xC0, 0xF3, 0xAA, 0x89, 0xD7, 0x8B, 
	0x5D, 0x08, 0x8D, 0x73, 0x20, 0x6A, 0x10, 0x59, 0x51, 0xF3, 
	0xA4, 0x59, 0x4A, 0x42, 0x49, 0x78, 0x0F, 0x8A, 0x02, 0x3C, 
	0x41, 0x72, 0xF6, 0x3C, 0x5A, 0x77, 0xF2, 0x80, 0x0A, 0x20, 
	0xEB, 0xED, 0x89, 0xE1, 0x51, 0x53, 0xE8, 0x00, 0x00, 0x00, 
	0x00, 0x5F, 0x5E, 0x81, 0xC7, 0xA8, 0x00, 0x00, 0x00, 0x6A, 
	0x05, 0x59, 0xF3, 0xA5, 0x83, 0xC4, 0x54, 0x61, 0x5D, 0x29, 
	0xC0, 0x40, 0xC2, 0x0C, 0x00
};

t_patch logon_proof_hash_patch = {
	95,
	logon_proof_hash_patch_data,
	"logon_proof_hash"
};

/* Used to find function where client verifies hash */
char logon_proof_hash_verify_sig_data[] = {
	0xff,0x74, 0xff,0x1D, 0xff,0x6A, 0xff,0x0C, 0xff,0xE8, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0x00,0x00, 0xff,0x8B, 0xff,0x54, 0xff,0x24, 
	0xff,0x0C, 0xff,0x83, 0xff,0xEA, 0xff,0x0E, 0xff,0xF7, 0xff,0xDA, 
	0xff,0x1B, 0xff,0xD2, 0xff,0x83, 0xff,0xE2, 0xff,0xC5, 0xff,0x6A, 
	0xff,0x00, 0xff,0x83, 0xff,0xC2, 0xff,0x3C, 0xff,0x52, 0xff,0xEB, 
	0xff,0x31
};

t_sig logon_proof_hash_verify_sig = {
	31,
	logon_proof_hash_verify_sig_data,
	0,
	"logon_proof_hash_verify"
};

/* Force client accept */
char logon_proof_hash_verify_patch_data[] = {
	0x75
};

t_patch logon_proof_hash_verify_patch = {
	1,
	logon_proof_hash_verify_patch_data,
	"logon_proof_hash_verify_patch"
};


#endif

/* Used to find the function that uses the AUTHREQ_109 packet to verify
   the server is a battle.net server */
char auth_req_sig_data[] = { 
	0xff,0x75, 0xff,0x12, 0xff,0x83, 0xff,0xe8, 0xff,0x04, 
	0xff,0x83, 0xff,0xc1, 0xff,0x04, 0xff,0x83, 0xff,0xc2, 
	0xff,0x04, 0xff,0x83, 0xff,0xf8, 0xff,0x04, 0xff,0x73,
	0xff,0xec, 0xff,0x3b, 0xff,0xc3, 0xff,0x74, 0xff,0x5d,
};

t_sig auth_req_sig = {
	20,
	auth_req_sig_data,
	0,
	"auth_req"
};

/* Force verify */
char auth_req_patch_data[] = { 
	0x66, 0x90
};

t_patch auth_req_patch = {
	2,
	auth_req_patch_data,
	"auth_req"
};

#if ! defined USE_SRP3
/* The createaccount patches patch the client to send a plaintext password 
   that PvPGN can use when creating an account. There are three patches
   due to space limitations preventing one in place patch */
char create_account1_sig_data[] = {
	0xff,0x8B, 0xff,0x0E, 0xff,0x89, 0xff,0x7C, 0xff,0x24, 0xff,0x18,
	0xff,0xE8, 0xff,0x6B, 0xff,0xF9, 0xff,0xFF, 0xff,0xFF, 0xff,0x8B,
	0xff,0x54, 0xff,0x24, 0xff,0x18, 0xff,0x6A, 0xff,0x20, 0xff,0x8B,
	0xff,0xCF, 0xff,0xE8, 0xff,0xDE, 0xff,0x1D, 0xff,0x00, 0xff,0x00,
	0xff,0x8B, 0xff,0x4C, 0xff,0x24, 0xff,0x14
};

t_sig create_account1_sig = {
	28,
	create_account1_sig_data,
	24,
	"create_account1"
};

char create_account1_patch_data[] = {
	0xEB, 0x13, 0x90, 0x90
};

t_patch create_account1_patch = {
	4,
	create_account1_patch_data,
	"create_account1"
};

char create_account2_sig_data[] = {
	0xff,0xE8, 0xff,0xF5, 0xff,0x20, 0xff,0x00, 0xff,0x00, 0xff,0x8B,
	0xff,0xCF, 0xff,0xE8, 0xff,0xEE, 0xff,0x20, 0xff,0x00, 0xff,0x00,
	0xff,0x5F, 0xff,0x5E, 0xff,0xC2, 0xff,0x10, 0xff,0x00, 0xff,0xCC,
	0xff,0xCC
};

t_sig create_account2_sig = {
	19,
	create_account2_sig_data,
	17,
	"create_account2"
};

char create_account2_patch_data[] = {
	0xE8, 0xF3, 0x00, 0x00, 0x00, 0xEB, 0xE8
};

t_patch create_account2_patch = {
	7,
	create_account2_patch_data,
	"create_account2"
};

char create_account3_patch_data[] = {
	0x6A, 0x20, 0x59, 0x56, 0x57, 0x8B, 0xF3, 0x8B, 0x7C, 0x24,
	0x24, 0xF3, 0xA4, 0x5F, 0x5E, 0x8B, 0x4C, 0x24, 0x18, 0xC3,
	0x90, 0x90, 0x90
};

t_patch create_account3_patch = {
	23,
	create_account3_patch_data,
	"create_account3"
};
#endif

char desync_fix_sig_data[] = {
	0xff,0x51, 0xff,0xb9, 0x00,0x00, 0x00,0x00, 0x00,0x00,
	0x00,0x00, 0xff,0xe8, 0x00,0x00, 0x00,0x00, 0x00,0x00,
	0x00,0x00, 0xff,0xb8, 0xff,0x01
};

t_sig desync_sig = {
	13,
	desync_fix_sig_data,
	6,
	"desync"
};

char desync_fix_patch_data[] = {
	0x59, 0xEB, 0x02
};

t_patch desync_patch = {
	3,
	desync_fix_patch_data,
	"desync"
};

char memory_protect_sig_data[] = {
	0xFF,0x81, 0xFF,0xEC, 0xFF,0x20, 0xFF,0x02, 0xFF,0x00,
	0xFF,0x00, 0xFF,0xA1, 0x00,0x00, 0x00,0x00, 0x00,0x00,
	0x00,0x00, 0xFF,0x33, 0xFF,0xC4, 0xFF,0x89, 0xFF,0x84,
	0xFF,0x24, 0xFF,0x1C, 0xFF,0x02, 0xFF,0x00, 0xFF,0x00,
	0xFF,0x53, 0xFF,0x55, 0xFF,0x33, 0xFF,0xDB, 0xFF,0x56,
	0xFF,0x57, 0xFF,0x88, 0xFF,0x5C, 0xFF,0x24, 0xFF,0x24,
	0xFF,0x88, 0xFF,0x5C, 0xFF,0x24, 0xFF,0x25, 0xFF,0x88,
	0xFF,0x5C, 0xFF,0x24, 0xFF,0x26, 0xFF,0x88, 0xFF,0x5C,
	0xFF,0x24, 0xFF,0x27, 0xFF,0x88, 0xFF,0x5C, 0xFF,0x24,
	0xFF,0x28, 0xFF,0xC6, 0xFF,0x44, 0xFF,0x24, 0xFF,0x29,
	0xFF,0x01
};

t_sig memory_protect_sig = {
	51,
	memory_protect_sig_data,
	0,
	"memory_protect"
};

char memory_protect_patch_data[] = {
	0xC3
};

t_patch memory_protect_patch = {
	1,
	memory_protect_patch_data,
	"memory_protect"
};

char delay_reducer_sig_data[] = {
    0xFF,0x5E, 0xFF,0xE9, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
    0x00,0x00, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 
    0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 0xFF,0xCC, 
    0xFF,0xCC, 0xFF,0xB8, 0xFF,0xFA, 0xFF,0x00, 0xFF,0x00, 
    0xFF,0x00, 0xFF,0xC3
};

t_sig delay_reducer_sig = {
	22,
	delay_reducer_sig_data,
	17,
	"delay"
};

char delay_reducer_patch_data[] = {
	0x64
};

t_patch delay_reducer_patch = {
	1,
	delay_reducer_patch_data,
	"delay"
};

char ad_disable_sig_data[] = {
    0xFF,0xA1, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    0xFF,0xC7, 0xFF,0x80, 0xFF,0x70, 0xFF,0x02, 0xFF,0x00,
    0xFF,0x00, 0xFF,0x01, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00,
    0xFF,0xBF, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
    0xFF,0x8B, 0xFF,0x0D, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
    0x00,0x00, 0xFF,0xE8, 0x00,0x00, 0x00,0x00, 0x00,0x00,
    0x00,0x00, 0xFF,0xA1
};

t_sig ad_disable_sig = {
	32,
	ad_disable_sig_data,
	26,
	"adRemove"
};

char ad_disable_patch_data[] = {
	0x0F, 0x1F, 0x44, 0x00, 0x00
};

t_patch ad_disable_patch = {
	5,
	ad_disable_patch_data,
	"adRemove"
};

/* by Rupan, 8/23/2009 -- reserved for future use
   this will find the call to logon_proof_hash in 1.24
   FIXME: need to mask out call address for generic use
*/
char lph_call_sig_data[] = {
    0xFF,0xE8, 0xFF,0x55, 0xFF,0x9E, 0xFF,0x03, 0xFF,0x00,
	0xFF,0x85, 0xFF,0xC0, 0xFF,0x74, 0xFF,0x2C, 0xFF,0x8B,
	0xFF,0x96, 0xFF,0xA8, 0xFF,0x00, 0xFF,0x00, 0xFF,0x00,
	0xFF,0x89, 0xFF,0x17, 0xFF,0x8B, 0xFF,0x8E, 0xFF,0xAC,
	0xFF,0x00, 0xFF,0x00, 0xFF,0x00, 0xFF,0x89, 0xFF,0x4F,
	0xFF,0x04, 0xFF,0x8B, 0xFF,0x96, 0xFF,0xB0, 0xFF,0x00,
	0xFF,0x00, 0xFF,0x00, 0xFF,0x89, 0xFF,0x57, 0xFF,0x08,
	0xFF,0x8B, 0xFF,0x8E, 0xFF,0xB4, 0xFF,0x00, 0xFF,0x00,
	0xFF,0x00
};


#if ! defined USE_SRP3
/* array of straightforward find sig, then patch patches */
void *game_patches[] = {
	&auth_req_sig, &auth_req_patch,
	&create_account1_sig, &create_account1_patch,
	&create_account2_sig, &create_account2_patch,
	&logon_proof_hash_verify_sig, &logon_proof_hash_verify_patch,
	&desync_sig, &desync_patch,
	&memory_protect_sig, &memory_protect_patch,
	NULL, NULL	/* sentinel */
};
#else
void *game_patches_srp3[] = {
	&auth_req_sig, &auth_req_patch,
	&desync_sig, &desync_patch,
	&memory_protect_sig, &memory_protect_patch,     
	NULL, NULL	/* sentinel */
};
  
#endif
void *unimportant_patches[] = {
    &ad_disable_sig, &ad_disable_patch,
    &delay_reducer_sig, &delay_reducer_patch,
    NULL, NULL /* sentinel */
};